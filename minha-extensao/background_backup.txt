// Variáveis globais
let ports = [];
let thirdPartyDomains = new Set(); // Para armazenar apenas domínios únicos de terceiros
let thirdPartyCookiesSet = new Set(); // Para armazenar cookies únicos de terceira parte
let suspiciousScriptsCount = 0; // Para armazenar o número de scripts potencialmente perigosos

browser.runtime.onConnect.addListener(function (port) {
    if (port.name === "port-from-popup") {
        ports.push(port);
        port.onDisconnect.addListener(function () {
            ports = ports.filter(p => p !== port);
        });
    }
});

// Função para extrair o domínio base do URL
function extractBaseDomain(url) {
    let hostname = new URL(url).hostname;
    let domainParts = hostname.split('.').slice(-2).join('.');
    return domainParts;
}

function logHost(host) {
    let baseDomain = extractBaseDomain(host);
    if (!thirdPartyDomains.has(baseDomain)) {
        thirdPartyDomains.add(baseDomain);
        console.log("Conexão com domínio de terceira parte detectada:", baseDomain);
        ports.forEach(port => {
            port.postMessage({ type: "host", host: baseDomain });
        });
    }
}

// Função para verificar cookies injetados
function logCookies(details) {
    const currentUrl = details.url;
    const currentDomain = new URL(currentUrl).hostname;

    browser.cookies.getAll({ url: currentUrl }).then(cookies => {
        let firstPartyCookies = 0;
        let thirdPartyCookies = 0;
        let sessionCookies = 0;
        let persistentCookies = 0;

        cookies.forEach(cookie => {
            let cookieIdentifier = `${cookie.domain}-${cookie.name}`; // Cria um identificador único para cada cookie

            if (cookie.domain.includes(currentDomain)) {
                firstPartyCookies++;
            } else if (!thirdPartyCookiesSet.has(cookieIdentifier)) {
                // Se o cookie não estiver no conjunto de cookies detectados
                thirdPartyCookiesSet.add(cookieIdentifier); // Adiciona ao conjunto para evitar recontagem
                thirdPartyCookies++;
            }

            if (cookie.session) {
                sessionCookies++;
            } else {
                persistentCookies++;
            }
        });

        ports.forEach(port => {
            port.postMessage({
                type: "cookies",
                firstParty: firstPartyCookies || 0,
                thirdParty: thirdPartyCookiesSet.size || 0, // Usa o tamanho do conjunto de cookies de terceiros
                session: sessionCookies || 0,
                persistent: persistentCookies || 0
            });
        });
    });
}

// Reiniciar os contadores e conjuntos quando o histórico é limpo
function resetDetections() {
    thirdPartyDomains.clear();
    thirdPartyCookiesSet.clear();
    suspiciousScriptsCount = 0;
}

browser.runtime.onMessage.addListener(function (message) {
    if (message.type === "resetDetections") {
        resetDetections(); // Reinicia os contadores
        console.log("Histórico reiniciado.");
        return; // Encerra a execução adicional deste ouvinte
    }
});

browser.webRequest.onCompleted.addListener(
    function (details) {
        logHost(details.url);
        logCookies(details); // Captura e classifica cookies quando a página é carregada
    },
    { urls: ["<all_urls>"] }
);

browser.webRequest.onBeforeRequest.addListener(
    function (details) {
        const url = new URL(details.url);
        const host = url.hostname;

        logHost(host);

        // Detecta se scripts estão sendo injetados
        if (details.type === "script") {
            console.log('%cScript detectado: ' + url.href, 'color: red; font-weight: bold;');
            suspiciousScriptsCount++; // Incrementa a contagem de scripts potencialmente perigosos

            // Envia a contagem de scripts para o popup
            ports.forEach(port => {
                port.postMessage({
                    type: "suspiciousScriptCount",
                    count: suspiciousScriptsCount
                });
            });
        }
    },
    { urls: ["<all_urls>"] },
    ["blocking"]
);

// Função para receber e enviar dados do content script sobre o armazenamento local
browser.runtime.onMessage.addListener(function (message) {
    if (message.type === "storageData") {
        console.log("Recebendo dados do content script...");
        console.log("Dados do localStorage:", message.localStorage);
        console.log("Dados do sessionStorage:", message.sessionStorage);

        // Enviar os dados para o popup
        ports.forEach(port => {
            port.postMessage({
                type: "storageData",
                localStorage: message.localStorage,
                sessionStorage: message.sessionStorage
            });
        });
    } else if (message.type === "canvasFingerprint") {
        console.log(`Canvas fingerprinting detectado: método ${message.method} na página ${message.url}`);

        // Enviar uma notificação para o popup
        ports.forEach(port => {
            port.postMessage({
                type: "canvasFingerprint",
                method: message.method,
                url: message.url
            });
        });
    } else {
        console.log("Mensagem desconhecida recebida:", message);
    }
});

// Verifica alterações na página inicial
browser.settings.onChange.addListener((changes) => {
    if (changes.name === "homepageOverride") {
        console.log('%cA página inicial foi modificada!', 'color: red; font-weight: bold;', changes.value);
        ports.forEach(port => {
            port.postMessage({ type: "hijackWarning", warning: "A página inicial foi modificada!" });
        });
    }
});

// Verifica alterações no motor de busca padrão
browser.search.onDefaultSearchEngineChanged.addListener((engine) => {
    console.log('%cO motor de busca padrão foi alterado!', 'color: red; font-weight: bold;', engine.name);
    ports.forEach(port => {
        port.postMessage({ type: "hijackWarning", warning: "O motor de busca padrão foi alterado!" });
    });
});
